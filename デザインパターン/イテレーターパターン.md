# イテレーターパターン

コレクション（配列、リスト、ツリーなど）の走査ロジックをコレクション自体から分離することで、異なるデータ構造に対して統一的なアクセス方法を提供します。

インターフェースは「何ができるか」を定義する契約。クラスが「どうやるか」を実装する。
インターフェース（契約）     →  IEnumerable, IEnumerator
具体的なクラス（実装）       →  List<T>, ListEnumerator<T> など

IEnumerableは「IEnumeratorを提供できる能力があります」と宣言するためのインターフェース
IEnumerableを実装しているクラスで、GetEnumerator()を経由して、IEnumeratorのインスタンスを取得できる。

## 基本的な実装（IEnumerable/IEnumerator）

```C#
public class BookCollection : IEnumerable<Book> //IEnumerableを実装していると表現する。
{
    private List<Book> _books = new List<Book>();

    public void Add(Book book) => _books.Add(book);

    public IEnumerator<Book> GetEnumerator()
    {
        for (int i = 0; i < _books.Count; i++)
        {
            yield return _books[i];
        }
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

public class Book
{
    public string Title { get; set; }
    public string Author { get; set; }
}
```

### yield return

C#では、yield returnを使用することによって、
IEnumeratorの実装が裏で自動生成される。
　※IEnumeratorを実装しているクラスが実装される

### IEnumerable（コレクション側）

「列挙するための道具（IEnumerator）を渡す」ことです。
IEnumerableの価値は、IEnumerable<T>を引数にすることで
具体的なコレクションの型に依存せずに、汎用的なメソッドが作れること。
　※引数のデータ型として、IEnumerableを実装しているクラスを指定できる。

```C#
public interface IEnumerable<T>
{
    IEnumerator<T> GetEnumerator();  // 「イテレーターをどうぞ」と渡すだけ
}
```

### IEnumerator（カー ソル側）

状態を持ちながら、実際に要素を1つずつ辿っていきます。
```C#
public interface IEnumerator<T>
{
    T Current { get; }    // 今指している要素
    bool MoveNext();      // 次に進む（進めたらtrue）
    void Reset();         // 最初に戻る
}
```

## 分離されている理由

1. 複数箇所から同時に走査できる

```csharp
var books = new BookCollection();
books.Add(new Book { Title = "C#入門", Author = "山田" });
books.Add(new Book { Title = "デザインパターン", Author = "田中" });

var iter1 = books.GetEnumerator();  // 独立したカーソル1
var iter2 = books.GetEnumerator();  // 独立したカーソル2

iter1.MoveNext();  // iter1は「C#入門」を指す
iter1.MoveNext();  // iter1は「デザインパターン」を指す

iter2.MoveNext();  // iter2は「C#入門」を指す（iter1とは独立）
```

2. 汎用的なコードが書ける

```csharp
public void PrintAll(IEnumerable<Book> items)
{
    foreach (var book in items)
    {
        Console.WriteLine(book.Title);
    }
}

// どちらも渡せる
PrintAll(new BookCollection());
PrintAll(new List<Book>());
```

責務が分かれているので、それぞれを独立して変更・拡張できる

