# フォーム

## Server Actions

use serverを付与することで、
フォームから送信された場合でもサーバ側で処理ができる。

```tsx
"use server"
```

## zod

TypeScript用のスキーマ検証(バリデーション)ライブラリ

```bash
npm install zod
```

## useActionStateフック

ServerActionの実行結果の状態管理
サーバサイドでのバリデーションエラーの表示

## 実装例

ただこの実装例は例外を制御フローに使っているから微妙だと思う。
ContactSchema.pick({ name: true }).parse({name: value})の結果をbooleanで取得できると思うから、
それを分岐で使用するような実装にする

```tsx
// src/components/ContactForm.tsx
'use client'
import { submitContactForm } from "@/lib/actions/contact"
import { ContactSchema } from "@/validations/contact"
import { useActionState, useState } from "react"
import { z } from "zod"


export default function ContactForm() {
  const [state, formAction] = useActionState(submitContactForm,{
    success: false,
    errors: {}
  })

  const [clientErrors, setClientErrors] = useState({name:'', email:''})
  
  //フォーカスが外れた際のバリデーションチェック
  //クライアント側のチェック
  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    const { name, value } = e.target // フォーカスが外れたオブジェクトが何かを表す意味のname

    try{
      if(name === 'name'){
        ContactSchema.pick({ name: true }).parse({name: value}) //このピックでnameのチェックのみ行う
      } else if (name === 'email'){
        ContactSchema.pick({ email: true }).parse({email: value})
      }

      // エラーがなくなった場合のエラーのクリア
      // setClientErrorsは関数を引数として受け取る。
      // そして、受け取った関数に対して、現在の状態を引数として渡す。
      // だから、setClientErrorsにprevを引数に取るアロー関数を渡している。
      setClientErrors( prev =>({
        ...prev, //以前の状態を取得
        [name]: '' //同じキーが複数回定義されると後から定義されたほうが優先される。prevのnameを上書きしている
        
      }))

    } catch(error){
      if(error instanceof z.ZodError){
        const errorMessage = error.errors[0]?.message || ''
        setClientErrors( prev => ({
          ...prev,
          [name]: errorMessage
        }))
      }
    }
  }

  return (
    <div>
      <form action={formAction}>
        <div className="py-24 text-gray-600">
            <div className="mx-auto flex flex-col bg-white shadow-md p-8 md:w-1/2">
                <h2 className="text-lg mb-2">お問い合わせ</h2>
                <div className="mb-4">
                    <label htmlFor="name" className="text-sm">名前</label>
                    <input type="text" id="name" name="name" 
                    onBlur={handleBlur}
                    
                    className="
                    w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 outline-none py-1 px-3 leading-8" />
                    { state.errors.name && (
                      <p className="text-red-500 text-sm mt-1">{state.errors.name.join(',')}</p>
                    )}
                    { clientErrors.name && (
                      <p className="text-red-500 text-sm mt-1">{clientErrors.name}</p>
                    )}
                </div>
                <div className="mb-4">
                    <label htmlFor="email" className="text-sm">メールアドレス</label>
                    <input type="text" id="email" name="email" 
                    onBlur={handleBlur}
                    className="
                    w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 outline-none py-1 px-3 leading-8" />
                     { state.errors.email && (
                      <p className="text-red-500 text-sm mt-1">{state.errors.email.join(',')}</p>
                    )}
                     { clientErrors.email && (
                      <p className="text-red-500 text-sm mt-1">{clientErrors.email}</p>
                    )}
                </div>
                <button className="text-white bg-indigo-500 py-2 px-6 hover:bg-indigo-600 rounded text-lg">送信</button>
            </div>
        </div>
      </form>
    </div>
  )
}
```

```ts
// src/validations/contact.ts
import { z } from "zod";

export const ContactSchema = z.object({
  name: z.string()
  .min(3, "名前は3文字以上で入力してください。")
  .max(20, "名前は20文字以内で入力してください"),
  email: z.string()
  .min(1, "メールアドレスは必須です")
  .email("正しいメールアドレスの形式で入力してください")
})

export type ContactType = z.infer<typeof ContactSchema>
```

```ts
// src/lib/actions/contact.ts
"use server"
import { redirect } from "next/navigation"
import { ContactSchema } from "../../validations/contact"

// ActionStateの型定義
type ActionState = {
  success: boolean;
  errors: {
    name?: string[];
    email?: string[];
  };
  serverError?: string;
}

export async function submitContactForm(
  prevState: ActionState,
  formData: FormData
): Promise<ActionState> 
{
  const name = formData.get("name")
  const email = formData.get("email")

  // バリデーション
  const validationResult = ContactSchema.safeParse({name, email})

  if(!validationResult.success)
  {
    const errors = validationResult.error.flatten().fieldErrors
    console.log("サーバー側でエラー", errors)
    return {
      success: false,
      errors: {
        name: errors.name || [],
        email: errors.email || [],
      }
    }
  }

  // DB登録

  console.log("送信されたデータ:", {name, email})
  redirect('/contact/complete')
}

```

```tsx
// src/app/contacts/page.tsx
import ContactForm from "../../components/ContactForm"

export default function ContactPage() {
  return (
    <div>
      <ContactForm />
    </div>
  )
}
```

