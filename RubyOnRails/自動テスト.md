# 自動テスト

### 環境

```ruby
group :development, :test do
  gem 'rspec-rails'
  gem 'factory_bot_rails'
end
```

```bash
#初期設定
docker compose exec web bundle exec rails g rspec:install
```

```bash
#例：modelのテストファイル作成
docker compose exec web bundle exec rails generate rspec:model Task

#テストファイルの実行
docker compose exec web bundle exec rspec spec/models/task_spec.rb
```

- describe
  describeブロックは、テスト対象のクラスやメソッドなどのグループを定義
- context
  contextブロックは、特定の状況や条件に基づいてテストをグループ化する
- it
  itブロックは、特定のテストケースを定義し、1つのitブロックは1つのテストケースを表す

```ruby
describe "クラス名やメソッドの処理内容などを記載する" do
  context "状況や条件などを記載する" do
    it "テストケースの説明" do
      ...
    end
  end
end
```

### 便利

#### 特定のテストケースのみの処理

- itをfitにするとspec実行時にそのテストケースのみ実行するようfocusしてくれる
- itをxitにするとスキップしてくれる。

#### byebugでテストケース確認中

```
page.body
```

### テストケースを記載

```ruby
RSpec.describe Task, type: :model do
  describe "バリデーションチェック" do
    it "設定した全てのバリデーションが機能しているか" do end
    it "titleが被らない場合にバリデーションエラーが起きないか" do end
    it "titleがない場合にバリデーションが機能してinvalidになるか" do end
    it "statusがない場合にバリデーションが機能してinvalidになるか" do end
    it "titleが被った場合にuniqueのバリデーションが機能してinvalidになるか" do end
  end
  pending "add some examples to (or delete) #{__FILE__}"
end
```

### テストコードを記載(model)

```ruby
#spec/models/task_spec.rb
require 'rails_helper'

RSpec.describe Task, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
  describe 'バリデーションチェック' do
    it '設定したすべてのバリデーションが機能しているか' do
      task = build(:task)
      expect(task).to be_valid
      expect(task.errors).to be_empty
    end

    it 'titleがない場合にバリデーションが機能してinvalidになるか' do
      task_without_title = build(:task, title: "")
      expect(task_without_title).to be_invalid
      expect(task_without_title.errors[:title]).to eq ["can't be blank"]
    end

    it 'statusがない場合にバリデーションが機能してinvalidになるか' do
      task_without_status = build(:task, status: nil)
      expect(task_without_status).to be_invalid
      expect(task_without_status.errors[:status]).to eq ["can't be blank"]
    end

    it 'titleが被った場合にuniqueのバリデーションが機能してinvalidになるか' do
      task = create(:task)
      task_with_duplicated_title = build(:task, title: task.title)
      expect(task_with_duplicated_title).to be_invalid
      expect(task_with_duplicated_title.errors[:title]).to eq ["has already been taken"]
    end

    it 'titleが被らない場合にバリデーションエラーが起きないか' do
      task = create(:task)
      task_with_another_title = build(:task, title: 'another_title')
      expect(task_with_another_title).to be_valid
      expect(task_with_another_title.errors).to be_empty
    end
  end
end
```

## 検証メソッド

```ruby
expect(テスト対象の値).to マッチャー(期待する値)
expect(テスト対象の値).to eq(期待する値) #2つの値が等しいかどうかを比較
expect(テスト対象の値).to be true # be true : 値がtrueであるかどうかをチェックします
expect(テスト対象の値).to be false # be false : 値がfalseであるかどうかをチェックします
expect(テスト対象の値).to be_nil # be_nil : 値がnilであるかどうかをチェックします
expect(テスト対象の配列).to be_empty #空であるかどうか
expect(テスト対象の文字列).to be_empty #空であるかどうか
expect(テスト対象のハッシュ).to be_empty #空であるかどうか
expect(テスト対象のオブジェクト).to be_valid #オブジェクトがバリデーションに通るかどうか
expect(テスト対象のオブジェクトのエラーの配列).to be_empty #↑のセット実施すると良い
expect(object).to be_invalid #objectがバリデーションに合格しない場合にテストが成功
```

## factory bot

RSpecや他のテストフレームワークで使用されるRubyのライブラリであり、テストデータの生成を簡素化する

### factory botのセットアップ

```ruby
#spec/rails_helper.rb
...
  config.include FactoryBot::Syntax::Methods
end
```

### 設定例

```ruby
#spec/factories/tasks.rb
FactoryBot.define do
  factory :task do
    sequence(:title, "title_1")
    content { "content" }
    status { :todo }
    deadline { 1.week.from_now }
    association :user
  end
end

#spec/factories/users.rb
FactoryBot.define do
  factory :user do
    sequence(:email) { |n| "user_#{n}@example.com" }
    password { "password" }
    password_confirmation { "password" }
  end
end
```

```ruby
FactoryBot.define do
  factory :user do
    name { "らんてくん" }
    sequence(:email) { |n| "runteq_#{n}@example.com" }
    age { 3 }
  end
end

#使用時。データベースに実際にオブジェクトを保存する
user = FactoryBot.create(:user)
or
user = create(:user)
#データを変更する場合
user = FactoryBot.create(:user, name: "RUNTEQ")
or
user = create(:user, name: "RUNTEQ")

#データベースに保存されない
user = FactoryBot.build(:user)
or
user = build(:user)
#データを変更する場合
user = FactoryBot.build(:user, name: "RUNTEQ")
or
user = build(:user, name: "RUNTEQ")
```

### trait

FactoryBotでテストデータを定義する際に用いるオプション
テストパターン用のパターンを定義できる

```ruby
#rspec/models/user_spec.rb
FactoryBot.define do
  factory :user do
    name { '太郎' }

    trait :over_length_name do　#trait
      name {'a' * 11}
    end
  end
end

#使用時
RSpec.describe User, type: :model do
  describe 'バリデーションに関するテスト' do
    let!(:user) { create(:user, :over_length_name) } # rails_helper.rbに設定定義済み
  end
end
```



## system spec

```
group :test do
  gem 'capybara'
  gem 'selenium-webdriver'
  gem "webdrivers"
end
```

### ファイル作成

```bash
#手動でも可
docker compose exec web bundle exec rails g rspec:system task
```

### formatの設定

specコマンドを使って表示される形式のフォーマットを見やすく設定します。
`.rspec`ファイルに下記コードを記載してください。

```ruby
--format documentation
```

### webdriverの設定

system specでテストを動かすブラウザの設定をします。

```ruby
#spec/rails_helper.rb
...
# capybara等ファイルの読み込み設定
Dir[Rails.root.join('spec', 'support', '**', '*.rb')].sort.each { |f| require f }
...
  
RSpec.configure do |config|
...
  # ここから
  config.before(:each, type: :system) do
    driven_by :remote_chrome
    Capybara.server_host = IPSocket.getaddress(Socket.gethostname)
    Capybara.server_port = 4444
    Capybara.app_host = "http://#{Capybara.server_host}:#{Capybara.server_port}"
    Capybara.ignore_hidden_elements = false
  end
  # ここまで
end
```

```ruby
#spec/support/capybara.rb
Capybara.register_driver :remote_chrome do |app|
  options = Selenium::WebDriver::Chrome::Options.new
  options.add_argument('no-sandbox')
  options.add_argument('headless')
  options.add_argument('disable-gpu')
  options.add_argument('window-size=1680,1050')
  Capybara::Selenium::Driver.new(app, browser: :remote, url: ENV['SELENIUM_DRIVER_URL'], capabilities: options)
end
```

### capybara

Capybaraは、RSpecで統合テストを実行するためのDSL（ドメイン固有言語）
Capybaraは、ブラウザとのやり取りをシミュレートすることで、
ユーザーが実際に行うであろう操作（クリック、フォーム入力、ページ遷移など）
をテストコード内で再現できる

```ruby
# /usersに対してアクセスする
visit '/users'

# Railsで定義されているroot_pathに対してアクセスする
visit root_path

# 「ログイン」をクリックする
click_on 'ログイン'

# 「ユーザー名」に対して、'らんてくん'を入力する
fill_in 'ユーザー名', with: 'らんてくん'

# classが「title」の要素を探す
find('.title')

# 「言語」のセレクトボックスから'Ruby'を選択する
select 'Ruby', from: '言語'

# page全体のなかに'ようこそ'の文字列があるか確認する
expect(page).to have_content('ようこそ')
```

### 変数宣言

letはRSpecでよく使われるメソッドで、テストケース内で使用する変数を定義します。
変数は初めて参照された時に初期値が評価されます。
let!はletと似ていますが、変数を即座に評価します。
let!を使用すると、変数は定義された時点で初期化されます。

```ruby
...
# ↓ここではまだuserの変数が作られない
let(:user) { User.create(name: 'runteq', email: 'runteq@example.com') }
it 'userインスタンスが有効であること' do
  # ↓ここではじめて参照されるのでuserの変数が作られる
  expect(user).to be_valid
end
...
  
# ↓ここで定義されているのでuserの変数が作られる
let!(:user) { User.create(name: 'runteq', email: 'runteq@example.com') }
it 'userインスタンスが有効であること' do
  # ↓ここではすでに作成されているuserが読み込まれる
  expect(user).to be_valid
end
```

### 事前処理

before
各テストケースの実行前に共通のセットアップコードを実行します。
beforeを使用することで、テストケースごとに繰り返し実行するセットアップコードを簡潔に記述できます

```ruby
let(:user) { User.create(name: 'runteq', email: 'runteq@example.com') }
# ↓テスト前に処理を行う
before { login(user) }
...
```

### 処理のmodule化

RSpecで記載するコードもRubyなので、処理の共通化（module化）ができます。
以下はログインの処理をmodule化した例です。

```ruby
module LoginMacros
  def login(user)
    visit login_path
    fill_in 'メールアドレス', with: user.email
    fill_in 'パスワード', with: user.password
    click_on 'ログイン'
  end
end

#moduleに切り出した処理を以下のようにincludeして利用します。
RSpec.describe 'hogehoge', type: :system do
  include LoginMacros

  it 'ログインした後に...' do
    user = User.create(email: 'runteq@example.com', password: 'password')
    login(user)
    # ログイン後のテストを書く
  end
end
```

### テストサンプル

```ruby
#spec\rails_helper.rb
  config.include FactoryBot::Syntax::Methods
  config.include LoginMacros

  config.before(:each, type: :system) do
    driven_by :remote_chrome
    Capybara.server_host = IPSocket.getaddress(Socket.gethostname)
    Capybara.server_port = 4444
    Capybara.app_host = "http://#{Capybara.server_host}:#{Capybara.server_port}"
    Capybara.ignore_hidden_elements = false
  end
```

```ruby
#spec\factories\users.rb
FactoryBot.define do
  factory :user do
    sequence(:email) { |n| "user_#{n}@example.com" }
    password { "password" }
    password_confirmation { "password" }
  end
end
```

```ruby
#spec\support\capybara.rb
Capybara.register_driver :remote_chrome do |app|
  options = Selenium::WebDriver::Chrome::Options.new
  options.add_argument('no-sandbox')
  options.add_argument('headless')
  options.add_argument('disable-gpu')
  options.add_argument('window-size=1680,1050')
  Capybara::Selenium::Driver.new(app, browser: :remote, url: ENV['SELENIUM_DRIVER_URL'], capabilities: options)
end
```

```ruby
#spec\support\login_macros.rb
#何度も使用する事前ログイン処理をメソッドにしておく
module LoginMacros
  def login_as(user)
    visit root_path
    click_link 'Login'
    fill_in 'Email', with: user.email
    fill_in 'Password', with: 'password'
    click_button 'Login'
  end
end
```

```ruby
#spec\factories\tasks.rb
FactoryBot.define do
  factory :task do

    sequence(:title, "title_1")
    content { "content" }
    status { :todo }
    deadline { 1.week.from_now }
    association :user
  end
end
```

```ruby
#spec/system/user_sessions_spec.rb
require 'rails_helper'

RSpec.describe "UserSessions", type: :system do
  #単純な変数の定義。テスト用データが格納されている。
  #実態はspec/factoriesに記載がある
  let(:user) {create(:user)} 

  describe "ログイン前" do
    context  "フォームの入力値が正常" do
      if "ログイン処理が成功する"
        visit login_path
        fill_in "Email", with: user.email
        fill_in "Password", with: "password"
        click_button "Login"
        expect(page).to have_content "Login successful"
        expect(current_path).to eq root_path
      end
    end

    context  "フォームが未入力" do
      it "ログイン処理が失敗する" do
        visit login_path
        fill_in 'Email', with: ''
        fill_in 'Password', with: 'password'
        click_button 'Login'
        expect(page).to have_content 'Login failed'
        expect(current_path).to eq login_path
      end
    end

  describe 'ログイン後' do
    context 'ログアウトボタンをクリック' do
      it 'ログアウト処理が成功する' do
        #login_as - Deviseが提供するテストヘルパーメソッド
        #user - ログインさせたいユーザーオブジェクト（先ほどのlet(:user) { create(:user) }で作成したもの）
        login_as(user)
        click_link 'Logout'
        #ページ全体の中に指定文言があるかどうか
        expect(page).to have_content 'Logged out'
        expect(current_path).to eq root_path
      end
    end
  end
end

```

```ruby
require 'rails_helper'

RSpec.describe 'Users', type: :system do
  let(:user) { create(:user) }

  describe 'ログイン前' do
    describe 'ユーザー新規登録' do
      context 'フォームの入力値が正常' do
        it 'ユーザーの新規作成が成功する' do
          visit new_user_path
          fill_in 'Email', with: 'email@example.com'
          fill_in 'Password', with: 'password'
          fill_in 'Password confirmation', with: 'password'
          click_button 'SignUp'
          expect(page).to have_content 'User was successfully created.'
          expect(current_path).to eq login_path
        end
      end

      context 'メールアドレスが未入力' do
        it 'ユーザーの新規作成が失敗する' do
          visit new_user_path
          fill_in 'Email', with: ''
          fill_in 'Password', with: 'password'
          fill_in 'Password confirmation', with: 'password'
          click_button 'SignUp'
          expect(page).to have_content '1 error prohibited this user from being saved'
          expect(page).to have_content "Email can't be blank"
          expect(current_path).to eq users_path
        end
      end

      context '登録済のメールアドレスを使用' do
        it 'ユーザーの新規作成が失敗する' do
          existed_user = create(:user)
          visit new_user_path
          fill_in 'Email', with: existed_user.email
          fill_in 'Password', with: 'password'
          fill_in 'Password confirmation', with: 'password'
          click_button 'SignUp'
          expect(page).to have_content '1 error prohibited this user from being saved'
          expect(page).to have_content 'Email has already been taken'
          expect(current_path).to eq users_path
          expect(page).to have_field 'Email', with: existed_user.email
        end
      end
    end

    describe 'マイページ' do
      context 'ログインしていない状態' do
        it 'マイページへのアクセスが失敗する' do
          visit user_path(user)
          expect(page).to have_content('Login required')
          expect(current_path).to eq login_path
        end
      end
    end
  end

  describe 'ログイン後' do
    before { login_as(user) }

    describe 'ユーザー編集' do
      context 'フォームの入力値が正常' do
        it 'ユーザーの編集が成功する' do
          visit edit_user_path(user)
          fill_in 'Email', with: 'update@example.com'
          fill_in 'Password', with: 'update_password'
          fill_in 'Password confirmation', with: 'update_password'
          click_button 'Update'
          expect(page).to have_content('User was successfully updated.')
          expect(current_path).to eq user_path(user)
        end
      end

      context 'メールアドレスが未入力' do
        it 'ユーザーの編集が失敗する' do
          visit edit_user_path(user)
          fill_in 'Email', with: ''
          fill_in 'Password', with: 'password'
          fill_in 'Password confirmation', with: 'password'
          click_button 'Update'
          expect(page).to have_content('1 error prohibited this user from being saved')
          expect(page).to have_content("Email can't be blank")
          expect(current_path).to eq user_path(user)
        end
      end

      context '登録済のメールアドレスを使用' do
        it 'ユーザーの編集が失敗する' do
          visit edit_user_path(user)
          other_user = create(:user)
          fill_in 'Email', with: other_user.email
          fill_in 'Password', with: 'password'
          fill_in 'Password confirmation', with: 'password'
          click_button 'Update'
          expect(page).to have_content('1 error prohibited this user from being saved')
          expect(page).to have_content('Email has already been taken')
          expect(current_path).to eq user_path(user)
        end
      end

      context '他ユーザーの編集ページにアクセス' do
        let!(:other_user) { create(:user, email: "other_user@example.com") }

        it '編集ページへのアクセスが失敗する' do
          visit edit_user_path(other_user)
          expect(page).to have_content 'Forbidden access.'
          expect(current_path).to eq user_path(user)
        end
      end
    end

    describe 'マイページ' do
      context 'タスクを作成' do
        it '新規作成したタスクが表示される' do
          create(:task, title: 'test_title', status: :doing, user: user)
          visit user_path(user)
          expect(page).to have_content('You have 1 task.')
          expect(page).to have_content('test_title')
          expect(page).to have_content('doing')
          expect(page).to have_link('Show')
          expect(page).to have_link('Edit')
          expect(page).to have_link('Destroy')
        end
      end
    end
  end
end
```

```ruby
require 'rails_helper'

RSpec.describe 'Tasks', type: :system do
  let(:user) { create(:user) }
  let(:task) { create(:task) }

  describe 'ログイン前' do
    describe 'ページ遷移確認' do
      context 'タスクの新規登録ページにアクセス' do
        it '新規登録ページへのアクセスが失敗する' do
          visit new_task_path
          expect(page).to have_content('Login required')
          expect(current_path).to eq login_path
        end
      end

      context 'タスクの編集ページにアクセス' do
        it '編集ページへのアクセスが失敗する' do
          visit edit_task_path(task)
          expect(page).to have_content('Login required')
          expect(current_path).to eq login_path
        end
      end

      context 'タスクの詳細ページにアクセス' do
        it 'タスクの詳細情報が表示される' do
          visit task_path(task)
          expect(page).to have_content task.title
          expect(current_path).to eq task_path(task)
        end
      end

      context 'タスクの一覧ページにアクセス' do
        it 'すべてのユーザーのタスク情報が表示される' do
          task_list = create_list(:task, 3)
          visit tasks_path
          expect(page).to have_content task_list[0].title
          expect(page).to have_content task_list[1].title
          expect(page).to have_content task_list[2].title
          expect(current_path).to eq tasks_path
        end
      end
    end
  end

  describe 'ログイン後' do
    before { login_as(user) }

    describe 'タスク新規登録' do
      context 'フォームの入力値が正常' do
        it 'タスクの新規作成が成功する' do
          visit new_task_path
          fill_in 'Title', with: 'test_title'
          fill_in 'Content', with: 'test_content'
          select 'doing', from: 'Status'
          fill_in 'Deadline', with: DateTime.new(2020, 6, 1, 10, 30)
          click_button 'Create Task'
          expect(page).to have_content 'Title: test_title'
          expect(page).to have_content 'Content: test_content'
          expect(page).to have_content 'Status: doing'
          expect(page).to have_content 'Deadline: 2020/6/1 10:30'
          expect(current_path).to eq '/tasks/1'
        end
      end

      context 'タイトルが未入力' do
        it 'タスクの新規作成が失敗する' do
          visit new_task_path
          fill_in 'Title', with: ''
          fill_in 'Content', with: 'test_content'
          click_button 'Create Task'
          expect(page).to have_content '1 error prohibited this task from being saved:'
          expect(page).to have_content "Title can't be blank"
          expect(current_path).to eq tasks_path
        end
      end

      context '登録済のタイトルを入力' do
        it 'タスクの新規作成が失敗する' do
          visit new_task_path
          other_task = create(:task)
          fill_in 'Title', with: other_task.title
          fill_in 'Content', with: 'test_content'
          click_button 'Create Task'
          expect(page).to have_content '1 error prohibited this task from being saved'
          expect(page).to have_content 'Title has already been taken'
          expect(current_path).to eq tasks_path
        end
      end
    end

    describe 'タスク編集' do
      let!(:task) { create(:task, user: user) }
      let(:other_task) { create(:task, user: user) }
      before { visit edit_task_path(task) }

      context 'フォームの入力値が正常' do
        it 'タスクの編集が成功する' do
          fill_in 'Title', with: 'updated_title'
          select :done, from: 'Status'
          click_button 'Update Task'
          expect(page).to have_content 'Title: updated_title'
          expect(page).to have_content 'Status: done'
          expect(page).to have_content 'Task was successfully updated.'
          expect(current_path).to eq task_path(task)
        end
      end

      context 'タイトルが未入力' do
        it 'タスクの編集が失敗する' do
          fill_in 'Title', with: nil
          select :todo, from: 'Status'
          click_button 'Update Task'
          expect(page).to have_content '1 error prohibited this task from being saved'
          expect(page).to have_content "Title can't be blank"
          expect(current_path).to eq task_path(task)
        end
      end

      context '登録済のタイトルを入力' do
        it 'タスクの編集が失敗する' do
          fill_in 'Title', with: other_task.title
          select :todo, from: 'Status'
          click_button 'Update Task'
          expect(page).to have_content '1 error prohibited this task from being saved'
          expect(page).to have_content "Title has already been taken"
          expect(current_path).to eq task_path(task)
        end
      end

      context '他ユーザーのタスク編集ページにアクセス' do
        let!(:other_user) { create(:user, email: "other_user@example.com") }
        let!(:other_task) { create(:task, user: other_user) }

        it '編集ページへのアクセスが失敗する' do
          visit edit_task_path(other_task)
          expect(page).to have_content 'Forbidden access.'
          expect(current_path).to eq root_path
        end
      end
    end

    describe 'タスク削除' do
      let!(:task) { create(:task, user: user) }

      it 'タスクの削除が成功する' do
        visit tasks_path
        click_link 'Destroy'
        expect(page.accept_confirm).to eq 'Are you sure?'
        expect(page).to have_content 'Task was successfully destroyed'
        expect(current_path).to eq tasks_path
        expect(page).not_to have_content task.title
      end
    end
  end
end
```

