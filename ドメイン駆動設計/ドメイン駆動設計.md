# ドメイン駆動設計

## 値オブジェクト

値オブジェクトで重要なのは、同一性を持たない(IDを持たない)ということ。
IDを持つオブジェクトは値オブジェクトではない。
ただ、実際に値オブジェクトを実装する場面っていうのは限定的。
なぜならフレームワーク等で既に定義されているから。
例えば、金額オブジェクトは同一性も持たないので、値オブジェクトだが、これは既に存在している。

また、ユーザークラスのユーザー名を値オブジェクトとするかは要件次第となる。
ユーザー名自体を値オブジェクトしてしてしまえば、ユーザー名に関する処理や制約をまとめることができる。

### C#の`decimal`が値オブジェクトである理由

#### 不変性

```csharp
decimal price = 100.50m;
decimal newPrice = price + 50;  // 新しい値を作成
// price は 100.50 のまま（不変）
```

#### 値による等価性

```csharp
decimal a = 100.50m;
decimal b = 100.50m;
Console.WriteLine(a == b);  // True（値で比較）
```

#### 同一性を持たない

```csharp
// 100.50 という値に「どの100.50か」という概念はない
decimal price1 = 100.50m;
decimal price2 = 100.50m;
// どちらも同じ100.50という値
```

## エンティティ

エンティティで重要なのは、同一性を持つ(IDを持つ)ということ。同じ属性値を持っていても、IDが異なれば別のオブジェクトとして扱われる。値オブジェクトとは対照的に、エンティティはライフサイクルを通じて追跡される必要があるオブジェクト。

例えば、ユーザー、注文、商品などは通常エンティティとして実装される。これらは時間とともに属性が変化しても、同じオブジェクトとして識別できる必要がある。

### C#のクラスがエンティティである理由

#### 同一性を持つ

```csharp
public class User
{
    public Guid Id { get; private set; }
    public string Name { get; set; }
    
    public User(Guid id, string name)
    {
        Id = id;
        Name = name;
    }
}

User user1 = new User(Guid.NewGuid(), "太郎");
User user2 = new User(Guid.NewGuid(), "太郎");
// 名前は同じでも、IDが異なるため別のユーザー
```

#### 参照による等価性

```csharp
User userA = new User(Guid.Parse("123e4567-e89b-12d3-a456-426614174000"), "太郎");
User userB = new User(Guid.Parse("123e4567-e89b-12d3-a456-426614174000"), "太郎");
Console.WriteLine(userA == userB);  // False（参照で比較）
Console.WriteLine(userA.Id == userB.Id);  // True（IDで比較すれば同一）
```

#### 可変性

```csharp
User user = new User(Guid.NewGuid(), "太郎");
user.Name = "次郎";  // 属性を変更できる
// IDは変わらないため、同じユーザーとして識別される
```

#### ライフサイクルの追跡

```csharp
// 同じIDを持つユーザーは、状態が変化してもずっと「そのユーザー」
User user = new User(Guid.Parse("123e4567-e89b-12d3-a456-426614174000"), "太郎");
// 時間経過...
user.Name = "太郎（更新済み）";
user.Email = "taro@example.com";
// IDが同じなので、これは最初のuserと同一のエンティティ
```

## ドメインサービス

ドメインサービスで重要なのは、エンティティや値オブジェクトに属さないドメインロジックを表現するということ。特定のオブジェクトに帰属させると不自然になる振る舞いや、複数のオブジェクトをまたがる処理を担当する。

ドメインサービスが必要になるのは以下のような場合：

- 複数のエンティティや値オブジェクトを協調させる処理
- エンティティに持たせると責任過多になる処理
- 概念的に「サービス」として表現するのが自然な処理

例えば、ユーザー名の重複チェックは、Userエンティティ単体では実行できない（他のユーザー情報が必要）ため、ドメインサービスとして実装するのが適切。

### C#でのドメインサービスの実装例

#### ステートレス（状態を持たない）

```csharp
public class UserDomainService
{
    private readonly IUserRepository _userRepository;
    
    public UserDomainService(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }
    
    // サービス自体は状態を持たず、渡された引数で処理する
    public bool IsDuplicateUserName(string userName)
    {
        return _userRepository.Exists(userName);
    }
}
```

#### エンティティに属さない振る舞い

```csharp
// ❌ Userエンティティに持たせると不自然
public class User
{
    public bool IsDuplicate(IUserRepository repository)  // 不自然
    {
        return repository.Exists(this.Name);
    }
}

// ✅ ドメインサービスとして独立させる
public class UserDomainService
{
    public bool IsDuplicateUserName(string userName)
    {
        // 複数のユーザーを横断的にチェックする処理
        return _userRepository.Exists(userName);
    }
}
```

#### 複数のオブジェクトを協調させる処理

```csharp
public class TransferDomainService
{
    // 送金処理は2つの口座（Account）をまたがる
    public void Transfer(Account fromAccount, Account toAccount, decimal amount)
    {
        // どちらのAccountにも属さない振る舞い
        if (fromAccount.Balance < amount)
        {
            throw new InvalidOperationException("残高不足");
        }
        
        fromAccount.Withdraw(amount);
        toAccount.Deposit(amount);
    }
}
```

#### ドメイン知識の表現

```csharp
public class PricingService
{
    // 価格計算のドメインロジック
    // 商品にも注文にも完全には属さない知識
    public decimal CalculateTotalPrice(Order order, Customer customer)
    {
        decimal basePrice = order.GetTotalAmount();
        
        // 顧客ランクによる割引
        if (customer.IsPremium)
        {
            basePrice *= 0.9m;
        }
        
        // 時期による割引
        if (IsHolidaySeason())
        {
            basePrice *= 0.95m;
        }
        
        return basePrice;
    }
}
```

## リポジトリとは

リポジトリは、集約（Aggregate）の永続化と取得を担当するパターンです。データベースなどのインフラ層とドメイン層の間の橋渡し役として機能します。

### 主な役割

1. 永続化の抽象化
   - ドメイン層からデータベースの詳細を隠蔽
   - 「コレクションのように扱える」インターフェースを提供
2. 集約単位でのアクセス
   - 集約ルートを通じてのみアクセス
   - 集約全体を取得・保存する

## DTOの活用

DTOは「Data Transfer Object（データ転送オブジェクト）」の略で、ドメイン駆動設計（DDD）において、異なる層やシステム間でデータを転送するために使用される単純なオブジェクトです。

### DDDにおけるDTOの重要性

1. **ドメインモデルの保護** - 内部のドメインオブジェクトを直接外部に公開しない
2. **結合度の低減** - 各層が独立して変更できる
3. **ネットワーク効率** - 必要なデータだけをまとめて転送できる
4. **セキュリティ** - 公開したくない情報を隠せる

例えば、Userエンティティがあっても、APIレスポンスにはUserDTOを使い、パスワードなどの機密情報を除外して返すといった使い方をします。

```c#
// DBから取得したUserエンティティ（ドメインモデル）
class User {
    private Long id;
    private String name;
    private String email;
    private String passwordHash;  // 機密情報
    private String internalNote;  // 内部用メモ
    private LocalDateTime createdAt;
    // + ビジネスロジック
}

// クライアントに返すUserDTO
class UserDTO {
    private Long id;
    private String name;
    private String email;
    // passwordHashやinternalNoteは含まない
}
```

## アプリケーションサービス

DDDにおけるアプリケーションサービスは、**ユースケースを実現する層**で、ドメイン層とインフラ層を組み合わせて、具体的な業務処理の流れを制御します。

## 主な役割

**1. ユースケースの実行**

- 「ユーザー登録」「注文処理」などの業務フローを実現
- 複数のドメインオブジェクトを協調させる

**2. トランザクション管理**

- データベースのトランザクション境界を定義
- 処理全体の整合性を保証

**3. ドメインロジックの呼び出し**

- 自分自身はビジネスルールを持たない
- ドメインモデルに処理を委譲する

## コマンドオブジェクトとは

「これから○○する」という操作の意図を表現するデータクラス
技術的にはただのクラスだが、名前と使い方によって役割を明確にしたもの。

### 1. 実体はただのデータコンテナ
```ruby
class RegisterUserCommand
  attr_reader :email, :password, :name
  
  def initialize(email:, password:, name:)
    @email = email
    @password = password
    @name = name
    freeze  # 不変にする
  end
end
```

- コマンド自体は処理を持たない
- 実際の処理はハンドラーやサービスが行う
- データの入れ物に徹する

### 2. 名前が意図を表現する

`RegisterUserCommand` という名前から:
- **Register**: 登録という操作
- **User**: ユーザーに関する
- **Command**: これから実行する意図

が一目でわかる。

### 3. 操作ごとに専用クラスを作る
```ruby
# 登録時専用
class RegisterUserCommand
  attr_reader :email, :password, :name
end

# 更新時専用
class UpdateUserProfileCommand
  attr_reader :user_id, :name, :bio
  # passwordは含まない
end

# メールアドレス変更専用
class ChangeUserEmailCommand
  attr_reader :user_id, :new_email, :password
  # 本人確認用のpasswordが必要
end
```

## 普通のクラスとの違い

| 項目           | 普通のクラス             | コマンドオブジェクト |
| -------------- | ------------------------ | -------------------- |
| 目的           | ドメインの概念を表現     | 操作の意図を表現     |
| ライフサイクル | 長く存在する             | 一時的               |
| 可変性         | 状態が変化することもある | 不変(イミュータブル) |
| ロジック       | ビジネスロジックを持つ   | ロジックは持たない   |
| 使用タイミング | システム全体             | 特定の操作時のみ     |

## メリット

1. **操作の意図が明確になる**
   - コードを読む人に何をしようとしているかが伝わる

2. **必要なデータだけを受け取れる**
   - 登録にはpasswordが必要、更新には不要など

3. **バリデーションが適切に書ける**
   - 操作ごとに異なる検証ルールを適用できる

4. **処理の履歴を残しやすい**
   - コマンドをログに保存して監査に使える

5. **テストが書きやすい**
   - 入力データが明確になる

## デメリット

1. **クラスが増える**
   - 操作ごとにクラスを作るため、ファイル数が増加

2. **重複コードが発生する**
   - 登録と更新で同じ項目がある場合、両方に実装が必要

3. **シンプルな処理には過剰**
   - 基本的なCRUDには不要な複雑さを生む

## 使うべき場面

### 使うと良い場合

- 操作が複雑で、バリデーションルールが大きく異なる
- 非同期処理やイベント駆動が必要
- 複数の入口(WebUI、API、管理画面)から同じ操作を実行
- 操作履歴を保存して監査ログに使いたい
- CQRSパターンを採用している

### 使わなくて良い場合

- シンプルなCRUD操作
- 小〜中規模のアプリケーション
- Railsのストロングパラメータで十分な場合

## 実装例
```ruby
# コマンドオブジェクト(データのみ)
class StartBrainwritingCommand
  attr_reader :team_id, :theme, :time_limit
  
  def initialize(team_id:, theme:, time_limit:)
    @team_id = team_id
    @theme = theme
    @time_limit = time_limit
    validate!
    freeze
  end
  
  private
  
  def validate!
    raise ArgumentError, 'team_idは必須です' if team_id.blank?
    raise ArgumentError, 'themeは必須です' if theme.blank?
  end
end

# ハンドラー(実際の処理)
class StartBrainwritingCommandHandler
  def handle(command)
    session = BrainwritingSession.start(
      team_id: command.team_id,
      theme: command.theme,
      time_limit: command.time_limit
    )
    
    session_repository.save(session)
  end
end

# コントローラー
class BrainwritingSessionsController < ApplicationController
  def create
    command = StartBrainwritingCommand.new(
      team_id: params[:team_id],
      theme: params[:theme],
      time_limit: params[:time_limit]
    )
    
    handler = StartBrainwritingCommandHandler.new
    handler.handle(command)
    
    redirect_to brainwriting_session_path
  end
end
```

## まとめ

- コマンドオブジェクトは**技術的にはただのクラス**
- **名前と使い方**によって「操作の意図」を明確にする
- **操作ごとに専用のデータクラス**を作る
- メリットとデメリットを理解して**必要な場面で使う**
- シンプルなアプリケーションでは無理に使わなくてOK(YAGNI原則)

過度に設計パターンを適用すると複雑になるため、プロジェクトの規模や複雑さに応じて判断することが重要。

